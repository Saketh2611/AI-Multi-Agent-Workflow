import asyncio
import json
import uuid
import logging
from fastapi import FastAPI, WebSocket, WebSocketDisconnect
from fastapi.staticfiles import StaticFiles
from fastapi.responses import HTMLResponse, Response
from agents.graph import get_graph

# --- Setup ---
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

app = FastAPI()
app.mount("/static", StaticFiles(directory="static"), name="static")

# --- Session and Data Management ---
# Using dictionaries to manage connections and store data from agent runs
connections = {}
session_data = {}
agent_graph = get_graph()


# --- WebSocket Event Handlers ---
async def process_graph_event(session_id: str, event: dict):
    """Processes events from the LangGraph stream and sends updates to the client."""
    if not event or not isinstance(event, dict):
        return

    node_name = next(iter(event), None)
    if not node_name or not event[node_name]:
        return

    node_output = event[node_name]
    websocket = connections.get(session_id)
    if not websocket:
        return

    # A simple router to handle different agent outputs
    if node_name == "planner":
        plan_text = node_output.get('plan', '...')
        session_data[session_id]['plan'] = plan_text
        await websocket.send_json({"type": "progress", "stage": 0})
        await websocket.send_json({"type": "chat", "agent": "Planner", "message": plan_text})

    elif node_name == "researcher":
        research_text = node_output.get('research_info', '...')
        session_data[session_id]['research_info'] = research_text
        await websocket.send_json({"type": "progress", "stage": 1})
        await websocket.send_json({"type": "chat", "agent": "Researcher", "message": research_text})

    elif node_name == "coder":
        code_text = node_output.get('code', '').replace("```python", "").replace("```", "").strip()
        session_data[session_id]['code'] = code_text
        await websocket.send_json({"type": "progress", "stage": 2})
        await websocket.send_json({"type": "code", "code": code_text})
        await websocket.send_json({"type": "chat", "agent": "Coder", "message": "I have generated the code."})

    elif node_name == "reporter":
        report_text = node_output.get('final_report', '')
        session_data[session_id]['final_report'] = report_text
        
        # More robust metric parsing
        metrics = {"accuracy": "N/A", "processingTime": "N/A", "systemStatus": "Incomplete"}
        for line in report_text.split('\n'):
            if "Accuracy Score:" in line: metrics["accuracy"] = line.split(":", 1)[1].strip()
            elif "Processing Time:" in line: metrics["processingTime"] = line.split(":", 1)[1].strip()
            elif "System Status:" in line: metrics["systemStatus"] = line.split(":", 1)[1].strip()

        await websocket.send_json({"type": "progress", "stage": 3})
        await websocket.send_json({"type": "metrics", **metrics})
        await websocket.send_json({"type": "chat", "agent": "Reporter", "message": "Workflow complete."})


async def handle_get_report(session_id: str):
    """Compiles and sends the final report to the client."""
    websocket = connections.get(session_id)
    data = session_data.get(session_id, {})
    if not websocket or not data:
        return

    logger.info(f"Compiling report for session {session_id}")
    task = data.get('task', 'N/A')
    
    # Use the final report generated by the agent as the primary content
    report_content = data.get('final_report', "Report could not be generated.")
    
    safe_task_str = "".join(c for c in task if c.isalnum() or c in " _-").rstrip()[:40]
    filename = f"report_{safe_task_str}.md"

    await websocket.send_json({
        "type": "report_data",
        "filename": filename,
        "content": report_content
    })

# --- API Endpoints ---
@app.get("/", response_class=HTMLResponse)
async def get_root():
    """Serves the main HTML file."""
    try:
        with open("static/index.html", "r") as f:
            return HTMLResponse(content=f.read(), status_code=200)
    except FileNotFoundError:
        return HTMLResponse(content="<h1>Client HTML not found</h1>", status_code=404)

@app.get("/health")
async def health_check():
    """A simple endpoint for health checks to prevent server logs from being cluttered."""
    return {"status": "ok"}

@app.get("/favicon.ico", include_in_schema=False)
async def favicon():
    """Handles browser requests for the favicon to prevent log warnings."""
    return Response(status_code=204)


@app.websocket("/ws")
async def websocket_endpoint(websocket: WebSocket):
    """Main WebSocket endpoint to handle client communication."""
    await websocket.accept()
    session_id = str(uuid.uuid4())
    connections[session_id] = websocket
    session_data[session_id] = {}
    logger.info(f"New connection: {session_id}")
    
    config = {"configurable": {"thread_id": session_id}}

    try:
        while True:
            message_text = await websocket.receive_text()
            user_task = None

            # Differentiate between a command and a task
            try:
                message_json = json.loads(message_text)
                if message_json.get("type") == "get_report":
                    await handle_get_report(session_id)
                
            except json.JSONDecodeError:
                # Not a JSON command, so it's a user task
                user_task = message_text
                logger.info(f"Received task for {session_id}: {user_task}")
                session_data[session_id]['task'] = user_task

            # Only run the agent graph if a new user_task has been received
            if user_task:
                # Stream the agent graph execution
                async for event in agent_graph.astream(
                    {"task": user_task, "messages": []},
                    config=config,
                    stream_mode="updates"
                ):
                    await process_graph_event(session_id, event)

    except WebSocketDisconnect:
        logger.info(f"Connection closed: {session_id}")
    except Exception as e:
        logger.error(f"An error occurred in {session_id}: {e}", exc_info=True)
    finally:
        # Cleanup on disconnect or error
        if session_id in connections: del connections[session_id]
        if session_id in session_data: del session_data[session_id]